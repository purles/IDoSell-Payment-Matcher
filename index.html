<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDoSell Payment Matcher - Mapowanie wp≈Çat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Papa/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #4E3261 0%, #6B4C7A 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: #F3E8E1;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4E3261 0%, #6B4C7A 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            font-size: 20px;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4E3261;
        }

        .upload-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .upload-box {
            border: 2px dashed #4E3261;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fff9f5;
        }

        .upload-box:hover {
            border-color: #6B4C7A;
            background: #f5f0eb;
            transform: translateY(-2px);
        }

        .upload-box input[type="file"] {
            display: none;
        }

        .upload-box label {
            cursor: pointer;
            display: block;
        }

        .upload-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .upload-box h3 {
            font-size: 16px;
            color: #333;
            margin-bottom: 5px;
        }

        .upload-box p {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .file-name {
            font-size: 12px;
            color: #4E3261;
            font-weight: bold;
            margin-top: 10px;
            min-height: 20px;
        }

        button {
            background: linear-gradient(135deg, #4E3261 0%, #6B4C7A 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 50, 97, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.show {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert ul, .alert ol {
            margin: 10px 0 0 20px;
        }

        .alert li {
            margin-bottom: 5px;
        }

        .results-section {
            display: none;
        }

        .results-section.show {
            display: block;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .results-table thead {
            background: #667eea;
            color: white;
            position: sticky;
            top: 0;
        }

        .results-table th {
            padding: 12px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #764ba2;
        }

        .results-table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        .results-table tbody tr:hover {
            background: #fff9f5;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }

        .status-ok {
            background: #d4edda;
            color: #155724;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .order-link {
            color: #4E3261;
            text-decoration: none;
            font-weight: bold;
        }

        .order-link:hover {
            text-decoration: underline;
        }

        .order-items {
            max-height: 200px;
            overflow-y: auto;
            background: #fff9f5;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .order-item {
            padding: 4px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .order-item:last-child {
            border-bottom: none;
        }

        .discrepancy {
            color: #721c24;
            font-weight: bold;
        }

        .negative-discrepancy {
            color: #fff;
            background: #721c24;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .summary-box {
            background: #fff9f5;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .summary-box h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat {
            padding: 10px;
            background: #F3E8E1;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4E3261;
            margin-top: 5px;
        }

        .footer {
            background: #fff9f5;
            padding: 20px;
            text-align: center;
            color: #666;
            font-size: 12px;
            border-top: 1px solid #ddd;
        }

        @media (max-width: 768px) {
            .content {
                padding: 15px;
            }

            .header h1 {
                font-size: 20px;
            }

            .results-table {
                font-size: 11px;
            }

            .results-table th, .results-table td {
                padding: 8px;
            }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease-in;
        }

        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #F3E8E1;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-content h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        .modal-content .modal-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .modal-content p {
            margin: 10px 0;
            font-size: 16px;
            line-height: 1.6;
        }

        .modal-content .modal-stats {
            background: #fff9f5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4E3261;
        }

        .modal-content .modal-stat-item {
            margin: 10px 0;
            font-size: 14px;
        }

        .modal-content button {
            margin-top: 20px;
            padding: 12px 40px;
            font-size: 16px;
        }
    </style>
</head>
<body>
            <div id="summaryModal" class="modal">
            <div class="modal-content">
                <div class="modal-icon" id="modalIcon">‚úÖ</div>
                <h2 id="modalTitle">Parsowanie zako≈Ñczone!</h2>
                <div class="modal-stats" id="modalStats"></div>
                <p id="modalMessage"></p>
                <button onclick="closeSummaryModal()">Dalej ‚Üí</button>
            </div>
        </div>

    <div class="container">
        <div class="header">
            <h1>üìä IDoSell Payment Matcher v2.0</h1>
            <p>Mapowanie wp≈Çat od klient√≥w do cotygodniowych transz wyp≈Çat</p>
            <p style="font-size: 12px; margin-top: 8px; opacity: 0.8;">‚úÖ Poprawka: prowizje kart pobierane z pliku wyp≈Çat | obs≈Çuga zwrot√≥w | prowizja za wyp≈Çatƒô</p>
        </div>

        <div class="content">
            <!-- SEKCJA UPLOADU -->
            <div class="section">
                <h2>1Ô∏è‚É£ Za≈Çaduj pliki</h2>
                
                <div class="upload-container">
                    <div class="upload-box">
                        <label for="payoutFile">
                            <div class="upload-icon">üí∞</div>
                            <h3>Wyp≈Çaty do nas</h3>
                            <p>Cotygodniowe transze</p>
                            <input type="file" id="payoutFile" accept=".ods,.xlsx,.xls,.csv">
                            <div class="file-name" id="payoutFileName"></div>
                        </label>
                    </div>

                    <div class="upload-box">
                        <label for="blikFile">
                            <div class="upload-icon">üì±</div>
                            <h3>BLIK IdoPay</h3>
                            <p>Wp≈Çaty BLIK</p>
                            <input type="file" id="blikFile" accept=".ods,.xlsx,.xls,.csv">
                            <div class="file-name" id="blikFileName"></div>
                        </label>
                    </div>

                    <div class="upload-box">
                        <label for="paybyFile">
                            <div class="upload-icon">‚ö°</div>
                            <h3>PayByLink IdoPay</h3>
                            <p>Szybkie przelewy</p>
                            <input type="file" id="paybyFile" accept=".ods,.xlsx,.xls,.csv">
                            <div class="file-name" id="paybyFileName"></div>
                        </label>
                    </div>

                    <div class="upload-box">
                        <label for="cardsFile">
                            <div class="upload-icon">üí≥</div>
                            <h3>Karty p≈Çatnicze IdoPay</h3>
                            <p>Wp≈Çaty kartami</p>
                            <input type="file" id="cardsFile" accept=".ods,.xlsx,.xls,.csv">
                            <div class="file-name" id="cardsFileName"></div>
                        </label>
                    </div>

                    <div class="upload-box">
                        <label for="ordersFile">
                            <div class="upload-icon">üìã</div>
                            <h3>Zam√≥wienia (opcjonalnie)</h3>
                            <p>Dane klient√≥w</p>
                            <input type="file" id="ordersFile" accept=".csv">
                            <div class="file-name" id="ordersFileName"></div>
                        </label>
                    </div>
                </div>

                <div class="button-group">
                    <button onclick="processFiles()">‚ñ∂Ô∏è Przetw√≥rz pliki</button>
                    <button onclick="clearAll()">üîÑ Wyczy≈õƒá</button>
                </div>

                <div id="loadingIndicator" class="loading">
                    <div class="spinner"></div>
                    <p>Przetwarzanie plik√≥w...</p>
                </div>

                <div id="alertContainer"></div>
            </div>

            <!-- SEKCJA WYNIK√ìW -->
            <div class="section results-section" id="resultsSection">
                <h2>2Ô∏è‚É£ Wyniki mapowania</h2>

                <div id="summaryBox" class="summary-box">
                    <h3>üìà Podsumowanie</h3>
                    <div class="summary-stats" id="summaryStats"></div>
                </div>

                <div class="button-group">
                    <button onclick="exportToCSV()">üì• CSV (podsumowanie)</button>
                    <button onclick="exportDetailedCSV()">üì• CSV (szczeg√≥≈Çy)</button>
                    <button onclick="exportToODS()">üì• ODS (tekst)</button>
                    <button onclick="exportToODSNumeric()">üì• ODS (liczby)</button>
                    <button onclick="printResults()">üñ®Ô∏è Drukuj</button>
                </div>

                <div style="overflow-x: auto;">
                    <table class="results-table" id="resultsTable">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Data transzy (zaksiƒôgowania)</th>
                                <th>ID transzy</th>
                                <th>Kwota transzy (z≈Ç)</th>
                                <th>Wp≈Çaty od klient√≥w</th>
                                <th>Data p≈Çatno≈õci</th>
                                <th>Data z≈Ço≈ºenia</th>
                                <th>Klient</th>
                                <th>Kwota wp≈Çat (z≈Ç)</th>
                                <th>Prowizje (z≈Ç)</th>
                                <th>R√≥≈ºnica (z≈Ç)</th>
                                <th>Uwagi</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTableBody">
                        </tbody>
                    </table>
                </div>

                <div id="issuesContainer"></div>
            </div>
        </div>

        <div class="footer">
            ‚ÑπÔ∏è Narzƒôdzie przetwarzajƒÖcy dane lokalnie w przeglƒÖdarce ‚Ä¢ Brak przesy≈Çania danych na serwer
        </div>
    </div>

    <script>
        // ===== ZMIENNE GLOBALNE =====
        let parsedData = {
            payouts: [],
            blik: [],
            payby: [],
            cards: [],
            // NOWE: dane z pliku wyp≈Çat do prawid≈Çowego obliczania
            prowizjeOdWplat: [],  // wiersze "Prowizja od wp≈Çaty IdoPay"
            zwroty: [],           // wiersze "Zwrot"
            prowizjeZaWyplate: [] // wiersze "Prowizja za wyp≈Çatƒô"
        };
        let ordersData = {};
        let lastResults = null;

        
        // ===== DETEKCJA MIESIƒòCY =====
        function detectMonths() {
            const months = new Set();
            
            // Zbieraj miesiƒÖce z transz
            parsedData.payouts.forEach(p => {
                if (p.dateAdded) {
                    const monthKey = p.dateAdded.getFullYear() + '-' + String(p.dateAdded.getMonth() + 1).padStart(2, '0');
                    months.add(monthKey);
                }
            });
            
            // Zbieraj miesiƒÖce z wp≈Çat
            [...parsedData.blik, ...parsedData.payby, ...parsedData.cards].forEach(p => {
                if (p.dateBooked) {
                    const monthKey = p.dateBooked.getFullYear() + '-' + String(p.dateBooked.getMonth() + 1).padStart(2, '0');
                    months.add(monthKey);
                }
            });
            
            const sortedMonths = Array.from(months).sort().reverse();
            console.log('MiesiƒÖce w plikach:', sortedMonths);
            return sortedMonths;
        }

        // ===== SELEKTOR MIESIƒòCY =====
        function showMonthSelector(months) {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.innerHTML = '';
            
            const monthNames = {
                '01': 'Stycze≈Ñ', '02': 'Luty', '03': 'Marzec', '04': 'Kwiecie≈Ñ',
                '05': 'Maj', '06': 'Czerwiec', '07': 'Lipiec', '08': 'Sierpie≈Ñ',
                '09': 'Wrzesie≈Ñ', '10': 'Pa≈∫dziernik', '11': 'Listopad', '12': 'Grudzie≈Ñ'
            };
            
            const alert = document.createElement('div');
            alert.className = 'alert alert-info show';
            
            let html = `<strong>üìÖ Wybierz miesiƒÖc do rozliczenia:</strong><br><div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">`;
            
            months.forEach(month => {
                const [year, monthNum] = month.split('-');
                const monthName = monthNames[monthNum] || 'Nieznany';
                const displayText = `${monthName} ${year}`;
                
                html += `<button onclick="filterByMonth('${month}')" style="padding: 10px 20px;">${displayText}</button>`;
            });
            
            html += `</div>`;
            alert.innerHTML = html;
            alertContainer.appendChild(alert);
            
            console.log('Selektor miesiƒôcy wy≈õwietlony dla:', months);
        }

        function filterByMonth(selectedMonth) {
            console.log('Filtrowanie dla miesiƒÖca:', selectedMonth);
            
            const [year, month] = selectedMonth.split('-');
            const selectedMonthDate = new Date(year, parseInt(month) - 1, 1);
            const endDate = new Date(year, parseInt(month), 0, 23, 59, 59);
            
            // Znajd≈∫ transze w wybranym miesiƒÖcu
            const payoutsInMonth = parsedData.payouts.filter(p => {
                return p.dateAdded >= selectedMonthDate && p.dateAdded <= endDate;
            });
            
            console.log(`Transze w miesiƒÖcu: ${payoutsInMonth.length}`);
            
            // Punkt startowy: ostatnia transza sprzed wybranego miesiƒÖca
            let periodStartPayment = new Date(2000, 0, 1); // Default - od poczƒÖtku
            
            const payoutsBeforeMonth = parsedData.payouts.filter(p => {
                return p.dateAdded < selectedMonthDate;
            });
            
            if (payoutsBeforeMonth.length > 0) {
                // Sortuj po dacie dodania, aby znale≈∫ƒá ostatniƒÖ transszƒô
                const sortedBefore = payoutsBeforeMonth.sort((a, b) => b.dateAdded - a.dateAdded);
                periodStartPayment = sortedBefore[0].dateAdded; // Ostatnia transza sprzed miesiƒÖca
                console.log(`Punkt startowy (ostatnia transza poprzedniego miesiƒÖca): ${formatDate(periodStartPayment)}`);
            }
            
            // Filtruj transze - bierz z wybranego miesiƒÖca
            const filteredPayouts = payoutsInMonth;
            
            // Filtruj wp≈Çaty - od ostatniej transzy poprzedniego miesiƒÖca (exclusive) do konca wybranego miesiƒÖca (inclusive)
            const filteredBlik = parsedData.blik.filter(p => {
                return p.dateBooked > periodStartPayment && p.dateBooked <= endDate;
            });
            
            const filteredPayby = parsedData.payby.filter(p => {
                return p.dateBooked > periodStartPayment && p.dateBooked <= endDate;
            });

            const filteredCards = parsedData.cards.filter(p => {
                return p.dateBooked > periodStartPayment && p.dateBooked <= endDate;
            });
            
            // NOWE: Filtruj prowizje i zwroty
            const filteredProwizje = parsedData.prowizjeOdWplat.filter(p => {
                return p.dateBooked > periodStartPayment && p.dateBooked <= endDate;
            });
            
            const filteredZwroty = parsedData.zwroty.filter(z => {
                return z.dateBooked > periodStartPayment && z.dateBooked <= endDate;
            });
            
            const filteredProwZaWyplate = parsedData.prowizjeZaWyplate.filter(p => {
                return p.dateBooked > periodStartPayment && p.dateBooked <= endDate;
            });
            
            console.log(`Filtrowane wp≈Çaty: ${filteredBlik.length} BLIK + ${filteredPayby.length} PayByLink + ${filteredCards.length} Karty`);
            console.log(`Filtrowane prowizje: ${filteredProwizje.length}, zwroty: ${filteredZwroty.length}`);
            
            // Tymczasowo zastƒÖp dane
            const originalPayouts = parsedData.payouts;
            const originalBlik = parsedData.blik;
            const originalPayby = parsedData.payby;
            const originalCards = parsedData.cards;
            const originalProwizje = parsedData.prowizjeOdWplat;
            const originalZwroty = parsedData.zwroty;
            const originalProwZaWyplate = parsedData.prowizjeZaWyplate;
            
            parsedData.payouts = filteredPayouts;
            parsedData.blik = filteredBlik;
            parsedData.payby = filteredPayby;
            parsedData.cards = filteredCards;
            parsedData.prowizjeOdWplat = filteredProwizje;
            parsedData.zwroty = filteredZwroty;
            parsedData.prowizjeZaWyplate = filteredProwZaWyplate;
            
            // Mapowanie i wy≈õwietlanie
            const results = mapPayments();
            displayResults(results);
            
            // Przywr√≥ƒá oryginalne dane
            parsedData.payouts = originalPayouts;
            parsedData.blik = originalBlik;
            parsedData.payby = originalPayby;
            parsedData.cards = originalCards;
            parsedData.prowizjeOdWplat = originalProwizje;
            parsedData.zwroty = originalZwroty;
            parsedData.prowizjeZaWyplate = originalProwZaWyplate;
            
            document.getElementById('resultsSection').classList.add('show');
            
            // Scroll do wynik√≥w
            setTimeout(() => {
                document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
            }, 100);
        }

        // ===== OBS≈ÅUGA UPLOADU =====
        document.getElementById('payoutFile').addEventListener('change', function(e) {
            updateFileName('payoutFileName', this.files[0]);
        });

        document.getElementById('blikFile').addEventListener('change', function(e) {
            updateFileName('blikFileName', this.files[0]);
        });

        document.getElementById('paybyFile').addEventListener('change', function(e) {
            updateFileName('paybyFileName', this.files[0]);
        });

        document.getElementById('cardsFile').addEventListener('change', function(e) {
            updateFileName('cardsFileName', this.files[0]);
        });

        document.getElementById('ordersFile').addEventListener('change', function(e) {
            updateFileName('ordersFileName', this.files[0]);
        });

        function updateFileName(elementId, file) {
            if (file) {
                document.getElementById(elementId).textContent = '‚úÖ ' + file.name;
            }
        }


        // ===== PARSOWANIE ZAM√ìWIE≈É =====
        function parseOrders(csvData) {
            const orders = {};
            
            // csvData mo≈ºe byƒá array lub string
            let lines;
            if (Array.isArray(csvData)) {
                // Je≈õli to array - to ju≈º sparsowany CSV
                lines = csvData;
            } else if (typeof csvData === 'string') {
                // Je≈õli to string - parsuj go
                lines = csvData.split('\n');
            } else {
                console.error('B≈Çƒôdny format danych zam√≥wie≈Ñ');
                return orders;
            }
            
            if (lines.length < 2) {
                console.log('Brak danych w pliku zam√≥wie≈Ñ');
                return orders;
            }
            
            // Czytanie nag≈Ç√≥wk√≥w
            const headerLine = Array.isArray(lines[0]) ? lines[0] : parseCSVLine(lines[0]);
            const headers = headerLine.map(h => String(h).trim().replace(/^"|"$/g, ''));
            console.log('Nag≈Ç√≥wki zam√≥wie≈Ñ:', headers);
            
            // Indeksy kolumn
            const orderNumIdx = headers.indexOf('Nr zam√≥wienia');
            const customerTypeIdx = headers.indexOf('Typ klienta'); // Kolumna E (indeks 4)
            const firstNameIdx = headers.indexOf('Biling-Imiƒô'); // Kolumna F (indeks 5)
            const lastNameIdx = headers.indexOf('Biling-Nazwisko'); // Kolumna G (indeks 6)
            const companyIdx = headers.indexOf('Biling-Nazwa firmy'); // Kolumna H (indeks 7)
            const nipIdx = headers.indexOf('Biling-NIP'); // Kolumna I (indeks 8)
            
            if (orderNumIdx === -1) {
                console.error('Nie znaleziono kolumny "Nr zam√≥wienia"');
                console.log('Dostƒôpne kolumny:', headers);
                return orders;
            }
            
            console.log(`Kolumny: OrderNum=${orderNumIdx}, CustomerType=${customerTypeIdx}, FirstName=${firstNameIdx}, LastName=${lastNameIdx}, Company=${companyIdx}, NIP=${nipIdx}`);
            
            // Parsowanie wierszy
            for (let i = 1; i < lines.length; i++) {
                let cells;
                
                if (Array.isArray(lines[i])) {
                    cells = lines[i].map(c => String(c || '').trim());
                } else {
                    if (!lines[i].trim()) continue;
                    cells = parseCSVLine(lines[i]);
                }
                
                if (cells.length > orderNumIdx) {
                    const orderNum = cells[orderNumIdx].trim();
                    if (orderNum && !isNaN(orderNum)) {
                        const customerType = customerTypeIdx >= 0 ? cells[customerTypeIdx].trim() : '';
                        const firstName = firstNameIdx >= 0 ? cells[firstNameIdx].trim() : '';
                        const lastName = lastNameIdx >= 0 ? cells[lastNameIdx].trim() : '';
                        const company = companyIdx >= 0 ? cells[companyIdx].trim() : '';
                        const nip = nipIdx >= 0 ? cells[nipIdx].trim() : '';
                        
                        // Nazwisko klienta - priorytet: firma z NIPem > firma > imiƒô i nazwisko
                        let clientName = '';
                        if (customerType === 'Firma' && company) {
                            clientName = company;
                            if (nip) {
                                clientName += ` (NIP: ${nip})`;
                            }
                        } else {
                            clientName = (firstName + ' ' + lastName).trim();
                        }
                        
                        orders[parseInt(orderNum)] = {
                            firstName: firstName,
                            lastName: lastName,
                            company: company,
                            nip: nip,
                            customerType: customerType,
                            fullName: clientName
                        };
                    }
                }
            }
            
            console.log(`‚úì Za≈Çadowano ${Object.keys(orders).length} zam√≥wie≈Ñ`);
            return orders;
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ';' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }


                // ===== CZYTANIE PLIK√ìW =====
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        let data;
                        const fileName = file.name.toLowerCase();
                        
                        if (fileName.endsWith('.ods')) {
                            // Obs≈Çuga ODS - czytaj jako binarny i parsuj z XLSX
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: '' });
                            console.log(`Plik ${fileName}: ${data.length} wierszy`);
                            resolve(data);
                        } else if (fileName.endsWith('.csv')) {
                            // Obs≈Çuga CSV - w≈Çasny parser
                            const text = e.target.result;
                            const lines = text.split('\n');
                            data = [];
                            
                            lines.forEach(line => {
                                if (line.trim()) {
                                    // Parsowanie CSV z cudzys≈Çowami i ≈õrednikami
                                    const cells = parseCSVLine(line);
                                    data.push(cells);
                                }
                            });
                            
                            console.log(`Plik ${fileName}: ${data.length} wierszy`);
                            resolve(data);
                        } else {
                            // Obs≈Çuga XLSX/XLS
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: '' });
                            console.log(`Plik ${fileName}: ${data.length} wierszy`);
                            resolve(data);
                        }
                    } catch (error) {
                        console.error('B≈ÇƒÖd readFile:', error);
                        reject(error);
                    }
                };
                
                reader.onerror = function(error) {
                    reject(error);
                };
                
                // Obs≈Çuga binarnych dla XLSX/ODS, text dla CSV
                if (file.name.toLowerCase().endsWith('.csv')) {
                    reader.readAsText(file, 'UTF-8');
                } else {
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        // ===== PARSOWANIE DANYCH =====
        async function processFiles() {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.innerHTML = '';

            const payoutFile = document.getElementById('payoutFile').files[0];
            const blikFile = document.getElementById('blikFile').files[0];
            const paybyFile = document.getElementById('paybyFile').files[0];
            const cardsFile = document.getElementById('cardsFile').files[0];
            const ordersFile = document.getElementById('ordersFile').files[0];

            if (!payoutFile || !blikFile || !paybyFile) {
                showAlert('B≈ÇƒÖd', 'Musisz za≈Çadowaƒá pliki: Transze, BLIK i PayByLink!', 'error');
                return;
            }

            if (!ordersFile) {
                showAlert('Info', 'Plik zam√≥wie≈Ñ nie zosta≈Ç za≈Çadowany. Dane klient√≥w z orders.csv nie bƒôdƒÖ dostƒôpne (tylko z plik√≥w wp≈Çat).', 'info');
            }

            document.getElementById('loadingIndicator').style.display = 'block';

            try {
                const payoutData = await readFile(payoutFile);
                const blikData = await readFile(blikFile);
                const paybyData = await readFile(paybyFile);

                // Parsowanie danych
                parsedData.payouts = parsePayouts(payoutData);
                parsedData.blik = parsePayments(blikData, 'BLIK');
                parsedData.payby = parsePayments(paybyData, 'PayByLink');
                
                // Parsowanie kart je≈õli zosta≈Ç za≈Çadowany
                if (cardsFile) {
                    const cardsData = await readFile(cardsFile);
                    parsedData.cards = parsePayments(cardsData, 'Karta');
                } else {
                    parsedData.cards = [];
                }
                
                // Parsowanie zam√≥wie≈Ñ je≈õli zosta≈Ç za≈Çadowany
                if (ordersFile) {
                    const ordersCSVData = await readFile(ordersFile);
                    ordersData = parseOrders(ordersCSVData);
                }

                // Walidacja
                const validationResults = validateData();
                
                if (validationResults.errors.length > 0) {
                    validationResults.errors.forEach(error => {
                        showAlert('B≈ÇƒÖd krityczny', error, 'error');
                    });
                    document.getElementById('loadingIndicator').style.display = 'none';
                    return;
                }

                if (validationResults.warnings.length > 0) {
                    validationResults.warnings.forEach(warning => {
                        showAlert('Ostrze≈ºenie', warning, 'warning');
                    });
                }

                // Detekcja miesiƒôcy w plikach
                const months = detectMonths();
                
                if (months.length > 1) {
                    // Je≈õli wiƒôcej ni≈º jeden miesiƒÖc - poka≈º selektor
                    document.getElementById('loadingIndicator').style.display = 'none';
                    showMonthSelector(months);
                } else {
                    // Je≈õli jeden miesiƒÖc - przetwarzaj normalnie
                    const results = mapPayments();
                    displayResults(results);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.getElementById('resultsSection').classList.add('show');
                }

            } catch (error) {
                console.error(error);
                showAlert('B≈ÇƒÖd', 'Nie uda≈Ço siƒô przeczytaƒá pliku: ' + error.message, 'error');
                document.getElementById('loadingIndicator').style.display = 'none';
            }
        }

        function parsePayouts(rawData) {
            console.log('=== PARSEOWANIE PAYOUTS (ROZSZERZONE) ===');
            console.log(`Surowe dane: ${rawData.length} wierszy`);
            
            // Nag≈Ç√≥wek jest w wierszu 3 (indeks 3)
            let headerRowIndex = 3;
            
            // Szukam wiersza nag≈Ç√≥wka - zabezpieczenie
            for (let i = 0; i < Math.min(rawData.length, 15); i++) {
                const firstCell = String(rawData[i]?.[0] || '').trim();
                if (firstCell.includes('Numer zam√≥wienia')) {
                    headerRowIndex = i;
                    console.log(`Header znaleziony w wierszu ${i}`);
                    break;
                }
            }

            const dataRows = rawData.slice(headerRowIndex + 1);
            console.log(`Dane do przetworzenia: ${dataRows.length} wierszy`);

            const payouts = [];
            const prowizjeOdWplat = [];
            const zwroty = [];
            const prowizjeZaWyplate = [];
            
            for (let idx = 0; idx < dataRows.length; idx++) {
                const row = dataRows[idx];
                if (!row || row.length === 0) continue;
                
                const typ = String(row[6] || '').trim();
                const dateAddedStr = String(row[7] || '').trim();
                const dateBookedStr = String(row[8] || '').trim();
                const amount = parseFloat(String(row[2] || '0').replace(',', '.'));
                const orderNumber = String(row[0] || '').trim();
                const paymentId = String(row[11] || '');
                
                // TRANSZE - Wyp≈Çaty na konto
                if (typ.includes('Wyp≈Çata ≈õrodk√≥w IdoPay na konto')) {
                    const parsed = {
                        dateAdded: parseDate(dateAddedStr),
                        dateBooked: parseDate(dateBookedStr),
                        amount: Math.abs(amount),
                        transactionId: String(row[1] || ''),
                        paymentId: paymentId,
                        rowData: row
                    };

                    if (parsed.dateBooked && !isNaN(parsed.dateBooked.getTime())) {
                        payouts.push(parsed);
                        console.log(`‚úì Transza: ${parsed.paymentId} | ${dateBookedStr} | ${Math.abs(amount)} z≈Ç`);
                    }
                }
                
                // PROWIZJE OD WP≈ÅAT - to jest klucz do prawid≈Çowego rozliczenia!
                else if (typ === 'Prowizja od wp≈Çaty IdoPay') {
                    const parsed = {
                        dateAdded: parseDate(dateAddedStr),
                        dateBooked: parseDate(dateBookedStr),
                        amount: Math.abs(amount), // zapisujemy jako warto≈õƒá dodatniƒÖ
                        paymentId: paymentId,
                        rowData: row
                    };
                    
                    if (parsed.dateBooked && !isNaN(parsed.dateBooked.getTime())) {
                        prowizjeOdWplat.push(parsed);
                    }
                }
                
                // ZWROTY
                else if (typ === 'Zwrot') {
                    const parsed = {
                        dateAdded: parseDate(dateAddedStr),
                        dateBooked: parseDate(dateBookedStr),
                        amount: amount, // ujemna warto≈õƒá
                        orderNumber: orderNumber,
                        paymentId: paymentId,
                        rowData: row
                    };
                    
                    if (parsed.dateBooked && !isNaN(parsed.dateBooked.getTime())) {
                        zwroty.push(parsed);
                        console.log(`‚úì Zwrot: zam√≥wienie ${orderNumber} | ${amount} z≈Ç | ${dateBookedStr}`);
                    }
                }
                
                // PROWIZJE ZA WYP≈ÅATƒò (0.30 z≈Ç za ka≈ºdƒÖ transzƒô)
                else if (typ === 'Prowizja za wyp≈Çatƒô') {
                    const parsed = {
                        dateAdded: parseDate(dateAddedStr),
                        dateBooked: parseDate(dateBookedStr),
                        amount: Math.abs(amount), // 0.30 z≈Ç
                        paymentId: paymentId,
                        rowData: row
                    };
                    
                    if (parsed.dateBooked && !isNaN(parsed.dateBooked.getTime())) {
                        prowizjeZaWyplate.push(parsed);
                    }
                }
            }

            console.log(`‚úÖ Za≈Çadowano ${payouts.length} transz`);
            console.log(`‚úÖ Za≈Çadowano ${prowizjeOdWplat.length} prowizji od wp≈Çat`);
            console.log(`‚úÖ Za≈Çadowano ${zwroty.length} zwrot√≥w`);
            console.log(`‚úÖ Za≈Çadowano ${prowizjeZaWyplate.length} prowizji za wyp≈Çatƒô`);
            
            // Zapisz do globalnych danych
            parsedData.prowizjeOdWplat = prowizjeOdWplat;
            parsedData.zwroty = zwroty;
            parsedData.prowizjeZaWyplate = prowizjeZaWyplate;
            
            return payouts;
        }

        function parsePayments(rawData, type) {
            console.log(`=== PARSEOWANIE PAYMENTS (${type}) ===`);
            console.log(`Surowe dane: ${rawData.length} wierszy`);
            
            // Szukam wiersza nag≈Ç√≥wka
            let headerRowIndex = 2;
            for (let i = 0; i < Math.min(rawData.length, 15); i++) {
                const firstCell = String(rawData[i]?.[0] || '').trim();
                if (firstCell.includes('Numer zam√≥wienia')) {
                    headerRowIndex = i;
                    console.log(`Header znaleziony w wierszu ${i}`);
                    break;
                }
            }

            const dataRows = rawData.slice(headerRowIndex + 1);
            console.log(`Dane do przetworzenia: ${dataRows.length} wierszy`);

            const filtered = dataRows
                .filter(row => {
                    if (!row || row.length === 0) return false;
                    const firstCol = String(row[0] || '').trim();
                    // Musi byƒá numerem zam√≥wienia (liczba)
                    return /^\d+$/.test(firstCol);
                })
                .map((row, idx) => {
                    const orderNumber = String(row[0] || '').trim();
                    const dateAddedStr = String(row[7] || '').trim(); // KOLUMNA H - Data dodania!
                    const dateBookedStr = String(row[8] || '').trim(); // Kolumna I - Data zaksiƒôgowania
                    const amount = parseFloat(String(row[2] || '0').replace(',', '.'));
                    const commission = parseFloat(String(row[13] || '0').replace(',', '.'));
                    const transactionId = String(row[1] || '');
                    
                    if (idx < 3 || idx % 30 === 0) {
                        console.log(`Wp≈Çata ${idx}: #${orderNumber} | Dodana: ${dateAddedStr} | Zaksiƒôgowana: ${dateBookedStr} | ${amount} z≈Ç`);
                    }
                    
                    return {
                        orderNumber,
                        transactionId,
                        dateAdded: parseDate(dateAddedStr), // Data z≈Ço≈ºenia zam√≥wienia
                        dateBooked: parseDate(dateBookedStr), // Data zaksiƒôgowania
                        amount,
                        commission,
                        type,
                        rowData: row
                    };
                })
                .filter(p => {
                    const valid = p.dateBooked && !isNaN(p.dateBooked.getTime()) && p.orderNumber;
                    if (!valid) {
                        console.log(`‚ùå Filtrowana (${type}): ${p.orderNumber} - ${p.dateBooked}`);
                    }
                    return valid;
                });

            console.log(`‚úÖ Za≈Çadowano ${filtered.length} wp≈Çat (${type})`);
            return filtered;
        }

        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // Pr√≥ba parsowania jako data ISO
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return date;
            }
            
            // Pr√≥ba parsowania polskiego formatu
            const match = dateStr.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2})/);
            if (match) {
                return new Date(match[1], parseInt(match[2]) - 1, match[3], match[4], match[5]);
            }
            
            return null;
        }

        // ===== WALIDACJA =====
        function validateData() {
            const errors = [];
            const warnings = [];

            if (parsedData.payouts.length === 0) {
                errors.push('Brak danych w pliku "Wyp≈Çaty do nas"');
            }
            if (parsedData.blik.length === 0 && parsedData.payby.length === 0 && parsedData.cards.length === 0) {
                errors.push('Brak danych w plikach z wp≈Çatami od klient√≥w');
            }

            // Sprawdzenie duplikat√≥w w wp≈Çatach
            const allPayments = [...parsedData.blik, ...parsedData.payby, ...parsedData.cards];
            const duplicateOrders = {};
            allPayments.forEach(p => {
                duplicateOrders[p.orderNumber] = (duplicateOrders[p.orderNumber] || 0) + 1;
            });

            Object.entries(duplicateOrders).forEach(([order, count]) => {
                if (count > 1) {
                    warnings.push(`Zam√≥wienie ${order} pojawia siƒô ${count} razy w plikach wp≈Çat`);
                }
            });

            // Sprawdzenie warto≈õci ujemnych (zwroty?)
            const negativePayments = allPayments.filter(p => p.amount < 0);
            if (negativePayments.length > 0) {
                warnings.push(`‚ö†Ô∏è Znaleziono ${negativePayments.length} wp≈Çat z ujemnymi kwotami (mo≈ºliwe zwroty)`);
            }

            return { errors, warnings };
        }

        // ===== MAPOWANIE WP≈ÅAT =====
        function mapPayments() {
            const allPayments = [...parsedData.blik, ...parsedData.payby, ...parsedData.cards];
            
            console.log('\n=== MAPOWANIE WP≈ÅAT (POPRAWIONA WERSJA) ===');
            console.log(`Transze do mapowania: ${parsedData.payouts.length}`);
            console.log(`Wp≈Çaty BLIK: ${parsedData.blik.length}`);
            console.log(`Wp≈Çaty PayByLink: ${parsedData.payby.length}`);
            console.log(`Wp≈Çaty Karty: ${parsedData.cards.length}`);
            console.log(`Razem wp≈Çat: ${allPayments.length}`);
            console.log(`Prowizje od wp≈Çat (z pliku wyp≈Çat): ${parsedData.prowizjeOdWplat.length}`);
            console.log(`Zwroty: ${parsedData.zwroty.length}`);
            console.log(`Prowizje za wyp≈Çatƒô: ${parsedData.prowizjeZaWyplate.length}`);

            // Sortujƒô transze od najstarszej do najnowszej
            const sortedPayouts = [...parsedData.payouts].sort((a, b) => a.dateAdded - b.dateAdded);
            
            console.log('\nTransze (posortowane po Data Dodania):');
            sortedPayouts.forEach((p, i) => {
                console.log(`  ${i}: Dodana: ${formatDate(p.dateAdded)} | Zaksiƒôgowana: ${formatDate(p.dateBooked)} | ID: ${p.paymentId}`);
            });

            const results = [];

            sortedPayouts.forEach((payout, index) => {
                console.log(`\n--- Mapowanie transzy ${index} (Dodana: ${formatDate(payout.dateAdded)}) ---`);
                
                let periodStart;
                let periodEnd = payout.dateAdded;

                if (index === 0) {
                    periodStart = new Date(2000, 0, 1);
                    console.log(`Pierwszy okres: od ${formatDate(periodStart)} do ${formatDate(periodEnd)}`);
                } else {
                    periodStart = sortedPayouts[index - 1].dateAdded;
                    console.log(`Okres: od ${formatDate(periodStart)} (excl) do ${formatDate(periodEnd)} (incl)`);
                }

                // Znalezienie wp≈Çat w danym oknie czasowym
                const matchingPayments = allPayments.filter(p => {
                    return p.dateBooked > periodStart && p.dateBooked <= periodEnd;
                });

                console.log(`‚úì Znaleziono ${matchingPayments.length} wp≈Çat`);
                
                // NOWE: Prowizje z pliku wyp≈Çat (NIE z kolumny w plikach p≈Çatno≈õci!)
                const matchingProwizje = parsedData.prowizjeOdWplat.filter(p => {
                    return p.dateBooked > periodStart && p.dateBooked <= periodEnd;
                });
                
                // NOWE: Zwroty z pliku wyp≈Çat
                const matchingZwroty = parsedData.zwroty.filter(z => {
                    return z.dateBooked > periodStart && z.dateBooked <= periodEnd;
                });
                
                // NOWE: Prowizja za wyp≈Çatƒô z pliku wyp≈Çat
                const matchingProwZaWyplate = parsedData.prowizjeZaWyplate.filter(p => {
                    return p.dateBooked > periodStart && p.dateBooked <= periodEnd;
                });

                // Obliczenia - PRAWID≈ÅOWA METODA
                const totalAmount = matchingPayments.reduce((sum, p) => sum + p.amount, 0);
                
                // Prowizje z pliku wyp≈Çat (prawid≈Çowe!)
                const totalCommissionReal = matchingProwizje.reduce((sum, p) => sum + p.amount, 0);
                
                // Prowizje z kolumny w plikach (do wy≈õwietlenia r√≥≈ºnicy)
                const totalCommissionFiles = matchingPayments.reduce((sum, p) => sum + p.commission, 0);
                
                // Zwroty (ujemne warto≈õci)
                const totalZwroty = matchingZwroty.reduce((sum, z) => sum + z.amount, 0);
                
                // Prowizja za wyp≈Çatƒô
                const totalProwZaWyplate = matchingProwZaWyplate.reduce((sum, p) => sum + p.amount, 0);
                
                // NETTO = Wp≈Çaty - Prowizje od wp≈Çat + Zwroty - Prowizja za wyp≈Çatƒô
                const totalNetAmount = totalAmount - totalCommissionReal + totalZwroty - totalProwZaWyplate;
                
                const difference = payout.amount - totalNetAmount;

                console.log(`  Suma wp≈Çat BRUTTO: ${totalAmount.toFixed(2)} z≈Ç`);
                console.log(`  Prowizje z pliku wyp≈Çat: ${totalCommissionReal.toFixed(2)} z≈Ç (${matchingProwizje.length} wierszy)`);
                console.log(`  Prowizje z plik√≥w BLIK/PayBy/Karty: ${totalCommissionFiles.toFixed(2)} z≈Ç (NIEU≈ªYWANE)`);
                console.log(`  Zwroty: ${totalZwroty.toFixed(2)} z≈Ç (${matchingZwroty.length} wierszy)`);
                console.log(`  Prowizja za wyp≈Çatƒô: ${totalProwZaWyplate.toFixed(2)} z≈Ç`);
                console.log(`  NETTO obliczone: ${totalNetAmount.toFixed(2)} z≈Ç`);
                console.log(`  Kwota transzy: ${payout.amount.toFixed(2)} z≈Ç`);
                console.log(`  R√ì≈ªNICA: ${difference.toFixed(2)} z≈Ç`);

                // Status
                let status = 'ok';
                let issues = [];

                if (Math.abs(difference) > 0.02) { // tolerancja zaokrƒÖglenia 2 grosze
                    status = 'warning';
                    if (difference < 0) {
                        issues.push(`‚ö†Ô∏è UJEMNA R√ì≈ªNICA: ${Math.abs(difference).toFixed(2)} z≈Ç`);
                    } else {
                        issues.push(`R√≥≈ºnica: +${difference.toFixed(2)} z≈Ç`);
                    }
                }

                if (matchingPayments.length === 0) {
                    status = 'warning';
                    issues.push('Brak powiƒÖzanych wp≈Çat od klient√≥w');
                }

                // Info o zwrotach
                if (matchingZwroty.length > 0) {
                    const zwrotyInfo = matchingZwroty.map(z => `#${z.orderNumber}: ${z.amount.toFixed(2)} z≈Ç`).join(', ');
                    issues.push(`Zwroty: ${zwrotyInfo}`);
                }

                console.log(`Status: ${status} | R√≥≈ºnica: ${difference.toFixed(2)} z≈Ç`);

                results.push({
                    payout,
                    matchingPayments,
                    matchingZwroty,        // NOWE
                    matchingProwizje,      // NOWE
                    status,
                    issues,
                    totalAmount,           // Brutto
                    totalCommission: totalCommissionReal,  // Prowizje z pliku wyp≈Çat
                    totalCommissionFiles,  // Prowizje z plik√≥w (do por√≥wnania)
                    totalZwroty,           // NOWE
                    totalProwZaWyplate,    // NOWE
                    totalNetAmount,        // Netto (prawid≈Çowe)
                    difference
                });
            });

            console.log('\n=== KONIEC MAPOWANIA ===\n');
            return results;
        }

        // ===== WY≈öWIETLANIE WYNIK√ìW =====
        function displayResults(results) {
            lastResults = results;
            const tbody = document.getElementById('resultsTableBody');
            const summaryBox = document.getElementById('summaryStats');
            tbody.innerHTML = '';

            let totalPayouts = 0;
            let totalPaymentsBrutto = 0;
            let totalPaymentsNetto = 0;
            let totalDifferences = 0;
            let issuesCount = 0;

            results.forEach((result, idx) => {
                totalPayouts += result.payout.amount;
                totalPaymentsBrutto += result.totalAmount;
                totalPaymentsNetto += result.totalNetAmount;
                totalDifferences += result.difference;

                if (result.issues.length > 0) {
                    issuesCount++;
                }

                // Je≈õli sƒÖ zam√≥wienia - ka≈ºde w osobnym wierszu
                if (result.matchingPayments.length > 0) {
                    result.matchingPayments.forEach((payment, payIdx) => {
                        const row = document.createElement('tr');
                        
                        // Status i info o transzy tylko w pierwszym wierszu
                        const statusClass = `status-${result.status}`;
                        const isFirstPayment = payIdx === 0;
                        
                        // Zaznacz ca≈Çy wiersz je≈õli ujemna r√≥≈ºnica
                        const isNegativeDiff = result.difference < -0.01;
                        if (isNegativeDiff && isFirstPayment) {
                            row.style.background = '#fff3cd';
                            row.style.fontWeight = 'bold';
                        }
                        
                        // Dane klienta - z orders.csv (opcjonalnie)
                        const clientInfo = ordersData[payment.orderNumber];
                        const clientName = clientInfo ? clientInfo.fullName : '-';
                        
                        // Data z≈Ço≈ºenia - TERAZ Z PLIK√ìW WP≈ÅAT (kolumna H - Data dodania)
                        const orderDate = payment.dateAdded ? formatDate(payment.dateAdded) : '-';
                        
                        row.innerHTML = `
                            <td>${isFirstPayment ? `<span class="status-badge ${statusClass}">${result.status === 'ok' ? '‚úÖ OK' : result.status === 'warning' ? '‚ö†Ô∏è UWAGA' : '‚ùå B≈ÅƒÑD'}</span>` : ''}</td>
                            <td>${isFirstPayment ? formatDate(result.payout.dateBooked) : ''}</td>
                            <td>${isFirstPayment ? result.payout.paymentId : ''}</td>
                            <td class="text-right">${isFirstPayment ? result.payout.amount.toFixed(2) : ''}</td>
                            <td>
                                <a href="https://purles.pl/panel/orderd.php?idt=${payment.orderNumber}" target="_blank" class="order-link">#${payment.orderNumber}</a> (${payment.type})
                            </td>
                            <td>${formatDate(payment.dateBooked)}</td>
                            <td>${orderDate}</td>
                            <td>${clientName}</td>
                            <td class="text-right">${payment.amount.toFixed(2)}</td>
                            <td class="text-right">-${payment.commission.toFixed(2)}</td>
                            <td class="text-right ${isFirstPayment && Math.abs(result.difference) > 0.01 ? (result.difference < 0 ? 'negative-discrepancy' : 'discrepancy') : ''}">${isFirstPayment ? result.difference.toFixed(2) : ''}</td>
                            <td>${isFirstPayment ? (result.issues.length > 0 ? result.issues.join('<br>') : '-') : ''}</td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                } else {
                    // Je≈õli brak zam√≥wie≈Ñ - wy≈õwietl wiersz z pustym polem zam√≥wie≈Ñ
                    const row = document.createElement('tr');
                    const statusClass = `status-${result.status}`;
                    
                    // Zaznacz ca≈Çy wiersz je≈õli ujemna r√≥≈ºnica
                    const isNegativeDiff = result.difference < -0.01;
                    if (isNegativeDiff) {
                        row.style.background = '#fff3cd';
                        row.style.fontWeight = 'bold';
                    }
                    
                    row.innerHTML = `
                        <td><span class="status-badge ${statusClass}">${result.status === 'ok' ? '‚úÖ OK' : result.status === 'warning' ? '‚ö†Ô∏è UWAGA' : '‚ùå B≈ÅƒÑD'}</span></td>
                        <td>${formatDate(result.payout.dateBooked)}</td>
                        <td>${result.payout.paymentId}</td>
                        <td class="text-right">${result.payout.amount.toFixed(2)}</td>
                        <td style="color: #999; font-style: italic;">Brak powiƒÖzanych zam√≥wie≈Ñ</td>
                        <td>-</td>
                        <td>-</td>
                        <td>-</td>
                        <td class="text-right">0.00</td>
                        <td class="text-right">0.00</td>
                        <td class="text-right ${Math.abs(result.difference) > 0.01 ? (result.difference < 0 ? 'negative-discrepancy' : 'discrepancy') : ''}">${result.difference.toFixed(2)}</td>
                        <td>${result.issues.length > 0 ? result.issues.join('<br>') : '-'}</td>
                    `;
                    
                    tbody.appendChild(row);
                }
            });

            // Poka≈º modal z podsumowaniem
            const hasDiscrepancies = results.some(r => Math.abs(r.difference) > 0.02);
            showSummaryModal(hasDiscrepancies, totalDifferences);

            // Oblicz dodatkowe sumy
            const totalZwroty = results.reduce((sum, r) => sum + (r.totalZwroty || 0), 0);
            const totalProwZaWyplate = results.reduce((sum, r) => sum + (r.totalProwZaWyplate || 0), 0);

            // Podsumowanie
            summaryBox.innerHTML = `
                <div class="stat">
                    <div class="stat-label">Transze</div>
                    <div class="stat-value">${results.length}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Kwota transz NETTO (z≈Ç)</div>
                    <div class="stat-value">${totalPayouts.toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Wp≈Çaty BRUTTO (z≈Ç)</div>
                    <div class="stat-value">${totalPaymentsBrutto.toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Prowizje od wp≈Çat (z≈Ç)</div>
                    <div class="stat-value">${(totalPaymentsBrutto - totalPaymentsNetto - totalZwroty + totalProwZaWyplate).toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Zwroty (z≈Ç)</div>
                    <div class="stat-value">${totalZwroty.toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Prowizje za wyp≈Çatƒô (z≈Ç)</div>
                    <div class="stat-value">-${totalProwZaWyplate.toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Wp≈Çaty NETTO (z≈Ç)</div>
                    <div class="stat-value">${totalPaymentsNetto.toFixed(2)}</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Razem r√≥≈ºnice (z≈Ç)</div>
                    <div class="stat-value" style="color: ${Math.abs(totalDifferences) < 0.1 ? 'green' : 'red'}; font-weight: bold;">${totalDifferences.toFixed(2)}</div>
                </div>
            `;
        }

        // ===== ALERT =====
        function showAlert(title, message, type) {
            const alertContainer = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type} show`;
            alert.innerHTML = `<strong>${title}:</strong> ${message}`;
            alertContainer.appendChild(alert);

            setTimeout(() => {
                alert.classList.remove('show');
                setTimeout(() => alert.remove(), 300);
            }, 5000);
        }

        // ===== EXPORT =====
        function exportToCSV() {
            // Pobieramy dane bezpo≈õrednio z lastResults zamiast z tabeli HTML
            // To daje pe≈ÇnƒÖ kontrolƒô nad formatowaniem
            
            if (!lastResults || lastResults.length === 0) {
                alert('Brak danych do eksportu. Najpierw wykonaj mapowanie.');
                return;
            }
            
            const csv = [];
            
            // Nag≈Ç√≥wki
            csv.push([
                'ID Transzy',
                'Data transzy',
                'Kwota transzy (z≈Ç)',
                'Suma wp≈Çat BRUTTO (z≈Ç)',
                'Suma prowizji (z≈Ç)',
                'Suma zwrot√≥w (z≈Ç)',
                'Prow. za wyp≈Çatƒô (z≈Ç)',
                'NETTO obliczone (z≈Ç)',
                'R√≥≈ºnica (z≈Ç)',
                'Status',
                'Liczba wp≈Çat',
                'Typy p≈Çatno≈õci'
            ].map(h => '"' + h + '"').join(';'));
            
            // Dane w polskim formacie
            lastResults.forEach(result => {
                const row = [
                    result.payout.paymentId || '-',
                    formatDateShort(result.payout.dateBooked),
                    formatAmountPL(result.payout.amount),
                    formatAmountPL(result.totalAmount),
                    formatAmountPL(result.totalCommission),
                    formatAmountPL(result.totalZwroty || 0),
                    formatAmountPL(result.totalProwZaWyplate || 0),
                    formatAmountPL(result.totalNetAmount),
                    formatAmountPL(result.difference),
                    Math.abs(result.difference) < 0.02 ? 'OK' : 'ROZBIE≈ªNO≈öƒÜ',
                    result.matchingPayments.length,
                    [...new Set(result.matchingPayments.map(p => p.type))].join(', ')
                ];
                csv.push(row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(';'));
            });
            
            // BOM dla UTF-8 (≈ºeby Excel poprawnie odczyta≈Ç polskie znaki)
            const BOM = '\uFEFF';
            downloadFile(BOM + csv.join('\n'), 'idosell-mapowanie-' + formatDateShort(new Date()).replace(/\./g, '-') + '.csv', 'text/csv;charset=utf-8');
        }

        function exportToODS() {
            if (!lastResults || lastResults.length === 0) {
                alert('Brak danych do eksportu. Najpierw wykonaj mapowanie.');
                return;
            }
            
            const data = [];
            
            // Nag≈Ç√≥wki
            data.push([
                'ID Transzy',
                'Data transzy',
                'Kwota transzy (z≈Ç)',
                'Suma wp≈Çat BRUTTO (z≈Ç)',
                'Suma prowizji (z≈Ç)',
                'Suma zwrot√≥w (z≈Ç)',
                'Prow. za wyp≈Çatƒô (z≈Ç)',
                'NETTO obliczone (z≈Ç)',
                'R√≥≈ºnica (z≈Ç)',
                'Status',
                'Liczba wp≈Çat',
                'Typy p≈Çatno≈õci'
            ]);
            
            // Dane - jako tekst z polskim formatowaniem
            // (≈ºeby ODS/Excel nie pr√≥bowa≈Ç ich interpretowaƒá)
            lastResults.forEach(result => {
                data.push([
                    String(result.payout.paymentId || '-'),
                    formatDateShort(result.payout.dateBooked),
                    formatAmountPL(result.payout.amount),
                    formatAmountPL(result.totalAmount),
                    formatAmountPL(result.totalCommission),
                    formatAmountPL(result.totalZwroty || 0),
                    formatAmountPL(result.totalProwZaWyplate || 0),
                    formatAmountPL(result.totalNetAmount),
                    formatAmountPL(result.difference),
                    Math.abs(result.difference) < 0.02 ? 'OK' : 'ROZBIE≈ªNO≈öƒÜ',
                    String(result.matchingPayments.length),
                    [...new Set(result.matchingPayments.map(p => p.type))].join(', ')
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);
            
            // Ustawienie szeroko≈õci kolumn
            ws['!cols'] = [
                {wch: 12}, // ID
                {wch: 12}, // Data
                {wch: 18}, // Kwota transzy
                {wch: 18}, // Brutto
                {wch: 15}, // Prowizje
                {wch: 15}, // Zwroty
                {wch: 15}, // Prow za wyp≈Ç
                {wch: 18}, // Netto
                {wch: 12}, // R√≥≈ºnica
                {wch: 12}, // Status
                {wch: 10}, // Liczba
                {wch: 20}  // Typy
            ];
            
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Mapowanie');
            XLSX.writeFile(wb, 'idosell-mapowanie-' + formatDateShort(new Date()).replace(/\./g, '-') + '.ods');
        }
        
        // Eksport szczeg√≥≈Çowy - wszystkie wp≈Çaty
        function exportDetailedCSV() {
            if (!lastResults || lastResults.length === 0) {
                alert('Brak danych do eksportu. Najpierw wykonaj mapowanie.');
                return;
            }
            
            const csv = [];
            
            // Nag≈Ç√≥wki
            csv.push([
                'ID Transzy',
                'Data transzy',
                'Nr zam√≥wienia',
                'ID p≈Çatno≈õci',
                'Typ p≈Çatno≈õci',
                'Data wp≈Çaty',
                'Kwota BRUTTO (z≈Ç)',
                'Prowizja (z≈Ç)',
                'Kwota NETTO (z≈Ç)'
            ].map(h => '"' + h + '"').join(';'));
            
            // Dane
            lastResults.forEach(result => {
                result.matchingPayments.forEach(payment => {
                    const row = [
                        result.payout.paymentId || '-',
                        formatDateShort(result.payout.dateBooked),
                        payment.orderNumber || '-',
                        payment.paymentId || '-',
                        payment.type || '-',
                        formatDateShort(payment.dateBooked),
                        formatAmountPL(payment.amount),
                        formatAmountPL(payment.commission),
                        formatAmountPL(payment.amount - payment.commission)
                    ];
                    csv.push(row.map(cell => '"' + String(cell).replace(/"/g, '""') + '"').join(';'));
                });
            });
            
            const BOM = '\uFEFF';
            downloadFile(BOM + csv.join('\n'), 'idosell-szczegoly-' + formatDateShort(new Date()).replace(/\./g, '-') + '.csv', 'text/csv;charset=utf-8');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        // Eksport ODS z prawdziwymi liczbami (dla formu≈Ç)
        function exportToODSNumeric() {
            if (!lastResults || lastResults.length === 0) {
                alert('Brak danych do eksportu. Najpierw wykonaj mapowanie.');
                return;
            }
            
            const data = [];
            
            // Nag≈Ç√≥wki
            data.push([
                'ID Transzy',
                'Data transzy',
                'Kwota transzy',
                'Suma BRUTTO',
                'Suma prowizji',
                'Suma zwrot√≥w',
                'Prow. za wyp≈Çatƒô',
                'NETTO obliczone',
                'R√≥≈ºnica',
                'Status',
                'Liczba wp≈Çat'
            ]);
            
            // Dane jako liczby (dla formu≈Ç)
            lastResults.forEach(result => {
                data.push([
                    String(result.payout.paymentId || '-'),
                    formatDateShort(result.payout.dateBooked),
                    result.payout.amount,  // liczba
                    result.totalAmount,    // liczba
                    result.totalCommission, // liczba
                    result.totalZwroty || 0, // liczba
                    result.totalProwZaWyplate || 0, // liczba
                    result.totalNetAmount,  // liczba
                    result.difference,      // liczba
                    Math.abs(result.difference) < 0.02 ? 'OK' : 'ROZBIE≈ªNO≈öƒÜ',
                    result.matchingPayments.length // liczba
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);
            
            // Formatowanie kolumn liczbowych (ustawienie formatu z 2 miejscami po przecinku)
            const numericCols = [2, 3, 4, 5, 6, 7, 8]; // indeksy kolumn z kwotami
            const range = XLSX.utils.decode_range(ws['!ref']);
            
            for (let R = 1; R <= range.e.r; R++) { // od wiersza 1 (pomijamy nag≈Ç√≥wek)
                numericCols.forEach(C => {
                    const cellRef = XLSX.utils.encode_cell({r: R, c: C});
                    if (ws[cellRef] && typeof ws[cellRef].v === 'number') {
                        ws[cellRef].t = 'n'; // typ: number
                        ws[cellRef].z = '#,##0.00'; // format liczbowy
                    }
                });
            }
            
            // Szeroko≈õci kolumn
            ws['!cols'] = [
                {wch: 12}, {wch: 12}, {wch: 14}, {wch: 14}, {wch: 14},
                {wch: 12}, {wch: 14}, {wch: 14}, {wch: 12}, {wch: 12}, {wch: 10}
            ];
            
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Mapowanie');
            XLSX.writeFile(wb, 'idosell-mapowanie-numeric-' + formatDateShort(new Date()).replace(/\./g, '-') + '.ods');
        }

        function printResults() {
            window.print();
        }

        // ===== UTILITY =====
        function formatDate(date) {
            if (!date) return '-';
            const d = new Date(date);
            // Sztywny polski format: DD.MM.YYYY HH:MM
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            return `${day}.${month}.${year} ${hours}:${minutes}`;
        }
        
        // Format daty bez godziny (do eksportu)
        function formatDateShort(date) {
            if (!date) return '-';
            const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            return `${day}.${month}.${year}`;
        }
        
        // Format kwoty z przecinkiem (polski format)
        function formatAmountPL(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            return value.toFixed(2).replace('.', ',');
        }

        function clearAll() {
            document.getElementById('payoutFile').value = '';
            document.getElementById('blikFile').value = '';
            document.getElementById('paybyFile').value = '';
            document.getElementById('cardsFile').value = '';
            document.getElementById('ordersFile').value = '';
            document.getElementById('payoutFileName').textContent = '';
            document.getElementById('blikFileName').textContent = '';
            document.getElementById('paybyFileName').textContent = '';
            document.getElementById('cardsFileName').textContent = '';
            document.getElementById('ordersFileName').textContent = '';
            document.getElementById('alertContainer').innerHTML = '';
            document.getElementById('resultsSection').classList.remove('show');
            parsedData = { 
                payouts: [], 
                blik: [], 
                payby: [], 
                cards: [],
                prowizjeOdWplat: [],
                zwroty: [],
                prowizjeZaWyplate: []
            };
            ordersData = {};
        }


        // ===== OBS≈ÅUGA MODALA =====
        function showSummaryModal(hasDiscrepancies, totalDifference) {
            const modal = document.getElementById('summaryModal');
            const icon = document.getElementById('modalIcon');
            const title = document.getElementById('modalTitle');
            const stats = document.getElementById('modalStats');
            const message = document.getElementById('modalMessage');
            
            if (hasDiscrepancies) {
                icon.innerHTML = '‚ö†Ô∏è';
                title.innerHTML = 'Znaleziono rozbie≈ºno≈õci!';
                message.innerHTML = `≈ÅƒÖczna r√≥≈ºnica: <strong>${totalDifference.toFixed(2).replace('.', ',')} z≈Ç</strong><br><br>Sprawd≈∫ szczeg√≥≈Çy poni≈ºej.`;
                icon.style.color = '#ff9800';
            } else {
                icon.innerHTML = '‚úÖ';
                title.innerHTML = 'Wszystko OK!';
                message.innerHTML = 'Wszystkie transze siƒô zgadzajƒÖ. Brak rozbie≈ºno≈õci.';
                icon.style.color = '#4CAF50';
            }
            
            let statsHtml = '<div class="modal-stat-item"><strong>Transze:</strong> ' + lastResults.length + '</div>';
            let totalPayouts = lastResults.reduce((s, r) => s + r.payout.amount, 0);
            let totalNetto = lastResults.reduce((s, r) => s + r.totalNetAmount, 0);
            statsHtml += '<div class="modal-stat-item"><strong>Kwota NETTO:</strong> ' + totalPayouts.toFixed(2).replace('.', ',') + ' z≈Ç</div>';
            statsHtml += '<div class="modal-stat-item"><strong>Wp≈Çaty NETTO:</strong> ' + totalNetto.toFixed(2).replace('.', ',') + ' z≈Ç</div>';
            statsHtml += '<div class="modal-stat-item"><strong>Razem rozbie≈ºno≈õci:</strong> ' + totalDifference.toFixed(2).replace('.', ',') + ' z≈Ç</div>';
            
            stats.innerHTML = statsHtml;
            modal.classList.add('show');
            
            setTimeout(() => closeSummaryModal(), 4000);
        }

        function closeSummaryModal() {
            const modal = document.getElementById('summaryModal');
            modal.classList.remove('show');
        }
    </script>
</body>
</html>
